substitutions:
  name: "barcode-scanner"
  friendly_name: "Barcode Scanner"
  uart_tx_pin: GPIO43
  uart_rx_pin: GPIO44
  display_led_pin: GPIO06


esphome:
  name: barcode-scanner
  friendly_name: Barcode Scanner
  platformio_options: 
    board_build.arduino.memory_type: qio_qspi
    board_build.f_cpu: 240000000L
    board_build.f_flash: 80000000L
    board_build.flash_mode: qio
    build_flags:
      - -Icustom_components/axp2101  

  on_boot:
    - priority: -100
      then:
        - delay: 5s
        - logger.log: "Konfiguriere Scanner: GM60..."

        # 1. Modus: Induction + Licht Immer An (Register 0x0000 -> 0x0F)
        - uart.write: [0x7E, 0x00, 0x08, 0x01, 0x00, 0x00, 0x0F, 0xAB, 0xCD]
        - delay: 200ms

        # 2. Farbe: Blau Dauer + Grün Erfolg (Register 0x001B -> 0x9A)
        - uart.write: [0x7E, 0x00, 0x08, 0x01, 0x00, 0x1B, 0x9A, 0xAB, 0xCD]
        - delay: 200ms

        # 3. Sound: Scan-Ton AN + Start-Ton AN (Register 0x000E -> 0x04)
        - uart.write: [0x7E, 0x00, 0x08, 0x01, 0x00, 0x0E, 0x04, 0xAB, 0xCD]
        
        - logger.log: "Setup Scanner GM60 abgeschlossen!"

    - priority: -50
      then:
        - lambda: |-
            // Register 0x62 auf 1000mA setzen (Wert 16 bzw. 0x10)
            uint8_t cmd[2] = {0x62, 16}; 
            if (id(bus_a).write(0x34, cmd, 2, true) == esphome::i2c::ERROR_OK) {
              ESP_LOGI("AXP2101", "Ladestrom erfolgreich auf 1000mA gesetzt!");
            } else {
              ESP_LOGE("AXP2101", "Fehler beim Setzen des Ladestroms!");
            }

    - priority: -90
      then:
        - lambda: |-
            // 1. PMU Power wie gehabt
            uint8_t pwr_en[2] = {0x90, 0xFF};
            id(bus_a).write(0x34, pwr_en, 2);

            // 2. ADC AKTIVIEREN (Das fehlende Puzzleteil!)
            // Wir schalten alle ADC-Kanäle ein (Register 0x30 auf 0xFF)
            uint8_t adc_en[2] = {0x30, 0xFF};
            id(bus_a).write(0x34, adc_en, 2);
          
            // 3. ADC Frequenz/Modus (Register 0x31)
            // Wir setzen 25Hz Messrate für flüssige Werte
            uint8_t adc_rate[2] = {0x31, 0x01};
            id(bus_a).write(0x34, adc_rate, 2);

            ESP_LOGI("AXP", "ADC und Sensoren aktiviert!");
                    
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: arduino
    version: recommended

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  min_auth_mode: WPA2
  use_address: 192.168.178.120
  fast_connect: true
  power_save_mode: NONE

psram:
  mode: octal
  speed: 80MHz
  
ota:
  - platform: esphome

safe_mode:

external_components:
  - source: 
      type: local
      path: custom_components
      
api:
  reboot_timeout: 0s
  on_client_connected:
    then:
      - if:
          condition:
            lambda: 'return !id(api_ready);'
          then:
            - delay: 5s 
            - lambda: 'id(api_ready) = true;'
            - rtttl.play: "kasse:d=16,o=7,b=200:e"
            - text_sensor.template.publish:
                id: last_ean
                state: "Bereit zum Scannen"

  services:
    # DIESER SERVICE HAT GEFEHLT:
    - service: set_last_product
      variables:
        value: string
      then:
        - text_sensor.template.publish:
            id: last_product
            state: !lambda 'return value;'

    - service: set_last_brand
      variables:
        value: string
      then:
        - text_sensor.template.publish:
            id: last_brand
            state: !lambda 'return value;'

    - service: set_last_kcal
      variables:
        value: string
      then:
        - text_sensor.template.publish:
            id: last_kcal
            state: !lambda 'return value;'

    - service: play_local_beep
      then:
        - rtttl.play: "success:d=32,o=6,b=200:c,e"
logger:
#  level: INFO
#  baud_rate: 0
    
# --- Hardware Setup ---
output:
  - platform: ledc
    pin: GPIO38 # alt 21
    id: buzzer_out
  - platform: ledc
    pin: ${display_led_pin}
    id: backlight_pwm
    
rtttl:
  output: buzzer_out
  id: my_rtttl

i2c:
  sda: GPIO08
  scl: GPIO07
  scan: true
  id: bus_a
  
pca9554:
  - id: p_c_a
    address: 0x20
    
spi:
  - id: display_spi
    clk_pin: GPIO05
    mosi_pin: GPIO01
    miso_pin: GPIO02

uart:
  - id: uart_bus
    baud_rate: 9600
    tx_pin: ${uart_tx_pin}
    rx_pin: ${uart_rx_pin}
    debug:
      direction: RX
      dummy_receiver: true
      after:
        timeout: 100ms 
      sequence:
        - lambda: |-
            if (!bytes.empty()) {
              uint32_t now = millis();
              
              // --- DOPPELSCAN SCHUTZ (3000ms = 3 Sekunden) ---
              if (now - id(last_scan_time) < 3000) {
                ESP_LOGD("scanner", "Doppelscan ignoriert.");
                return; 
              }
              
              // 1. Display aufwecken / Timer neu starten
              id(display_timer).execute();

              // Zeit merken
              id(last_scan_time) = now;

              // 2. Beep sofort abspielen
              id(my_rtttl).play("kasse:d=16,o=7,b=200:e");
              
              // 3. String-Verarbeitung
              std::string s = "";
              for (size_t i = 0; i < bytes.size(); i++) {
                uint8_t b = bytes[i];
                if (b >= 32 && b <= 126) { s += (char)b; }
              }

              if (!s.empty()) {
                id(last_ean).publish_state(s);
                ESP_LOGD("scanner", "Daten empfangen: %s", s.c_str());
              }
            }
# --- Sensoren & Logik ---
globals:
  - id: api_ready
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_scan_time
    type: uint32_t
    restore_value: no
    initial_value: '0'  
font:
  - file: "_fonts/arial.ttf"
    id: arial_font_18
    size: 35
    glyphs: 'ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüö€@<>/&|'
    
  - file: "_fonts/arial.ttf"
    id: arial_font
    size: 30
    glyphs: 'ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüö€@<>/&|'

  - file: "_fonts/arial.ttf"
    id: arial_font_bold
    size: 40 
    glyphs: 'ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüö€@<>/&|'

  - file: "_fonts/arial.ttf"
    id: arial_font_14
    size: 16
    glyphs: 'ß!?"%()+*=,-_.:°ø0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÄÜÖ abcdefghijklmnopqrstuvwxyzäüö€@<>/&|'
    
text_sensor:
  - platform: template
    id: last_ean
    name: "ean"
    on_value:
      then:
        - if:
            condition:
              lambda: |-
                return id(api_ready) && 
                       x != "Bereit zum Scannen" && 
                       x != "Verbindung..." && 
                       !x.empty();
            then:
              - delay: 15s
              - text_sensor.template.publish: { id: last_ean, state: "Bereit zum Scannen" }
              
  - platform: template
    id: last_product
    name: "last_product"

  - platform: template
    id: last_brand
    name: "last_brand"

  - platform: template
    id: last_kcal
    name: "last_kcal"

  # Der PMU Status als Klartext (Reg 01)
  - platform: template
    name: "PMU Status"
    id: pmu_status_text
    update_interval: 30s
    lambda: |-
      uint8_t reg = 0x01;
      uint8_t val = 0;
      if (id(bus_a).write(0x34, &reg, 1, true) == esphome::i2c::ERROR_OK) {
        if (id(bus_a).read(0x34, &val, 1) == esphome::i2c::ERROR_OK) {
          uint8_t dir = (val >> 5) & 0x03; // Bits 6:5
          uint8_t charge = val & 0x07;    // Bits 2:0
          
          if (dir == 0b01) return {"Laden"};
          if (dir == 0b10) return {"Entladen"};
          if (charge == 0b100) return {"Voll geladen"};
          return {"Standby"};
        }
      }
      return {"Keine Daten"};

  - platform: template
    name: "Ladestatus Detail"
    icon: "mdi:battery-check"
    lambda: |-
      uint8_t val = 0;
      if (id(bus_a).read(0x34, &val, 1) == esphome::i2c::ERROR_OK) {
        uint8_t dir = (val >> 5) & 0x03;    // Bit 6:5: Richtung
        uint8_t status = val & 0x07;       // Bit 2:0: Phase
        
        if (dir == 0b01) { // Lade-Modus
          if (status == 0b010) return {"Laden (Schnell/CC)"};
          if (status == 0b011) return {"Laden (Konst. Spannung/CV)"};
          return {"Wird geladen"};
        } else if (dir == 0b10) {
          return {"Akku-Betrieb (Entladen)"};
        }
        return {"Standby / Voll"};
      }
      return {"Fehler"};

sensor:
  # 1. Die Standard-Sensoren vom AXP2101
  - platform: axp2101
    battery_level:
      name: "Batterie Prozent"
      id: batterie_ladestand  # <--- ID für das Display-Lambda
    battery_voltage:
      name: "Batterie Spannung"
      id: batt_voltage

  # 2. Dein manuelles Ladelimit
  - platform: template
    name: "Ladelimit konfiguriert"
    id: reg_62_val
    unit_of_measurement: "mA"
    update_interval: 60s 
    lambda: |-
      uint8_t reg = 0x62;
      uint8_t n = 0;
      if (id(bus_a).write(0x34, &reg, 1, true) == esphome::i2c::ERROR_OK) {
        if (id(bus_a).read(0x34, &n, 1) == esphome::i2c::ERROR_OK) {
          n &= 0x1F;
          return (n <= 8) ? (float)(25 * n) : (float)(200 + 100 * (n - 8));
        }
      }
      return NAN;

  - platform: template
    name: "Akku Warnschwelle"
    id: akku_warnschwelle  # <--- Das hat gefehlt!
    unit_of_measurement: "%"
    icon: "mdi:bell-ring"
    lambda: |-
      uint8_t reg = 0x1A;
      uint8_t val = 0;
      if (id(bus_a).write(0x34, &reg, 1, true) == esphome::i2c::ERROR_OK) {
        if (id(bus_a).read(0x34, &val, 1) == esphome::i2c::ERROR_OK) {
          uint8_t level2 = (val >> 4) & 0x0F;
          return (float)(5 + level2); 
        }
      }
      return NAN;

  - platform: template
    name: "Chip Temperatur"
    id: chip_temp # Falls du sie auch im Display willst
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    lambda: |-
      uint8_t buffer[2];
      uint8_t reg = 0x3C;
      if (id(bus_a).write(0x34, &reg, 1, true) == esphome::i2c::ERROR_OK) {
        if (id(bus_a).read(0x34, buffer, 2) == esphome::i2c::ERROR_OK) {
          int16_t res = ((buffer[0] & 0x3F) << 8) | buffer[1];
          if (res == 0) return NAN;
          return (float)res * 0.1 - 677.3;
        }
      }
      return NAN;

# Nicht vergessen: Den Ladesensor für das "+" im Display brauchen wir auch noch
binary_sensor:
  - platform: template
    name: "Batterie Laden"
    id: batterie_laden
    lambda: |-
      uint8_t reg = 0x01;
      uint8_t status;
      if (id(bus_a).write(0x34, &reg, 1, true) == esphome::i2c::ERROR_OK) {
        if (id(bus_a).read(0x34, &status, 1) == esphome::i2c::ERROR_OK) {
          return (status & 0x20); // Bit 5: VBUS charging
        }
      }
      return {};
      
  - platform: status
    name: "System Status"
    id: system_status

  - platform: template
    name: "Akku Kritisch Alarm"
    device_class: battery_charging
    id: batt_crit_alarm
    lambda: |-
      uint8_t reg = 0x00;
      uint8_t val = 0;
      if (id(bus_a).write(0x34, &reg, 1, true) == esphome::i2c::ERROR_OK) {
        if (id(bus_a).read(0x34, &val, 1) == esphome::i2c::ERROR_OK) {
          // Bit 0 zeigt "Low Battery Warning" an
          return (val & 0x01); 
        }
      }
      return false;
  

light:
  - platform: monochromatic
    output: backlight_pwm
    name: Display Backlight
    id: display_backlight
    restore_mode: ALWAYS_ON
    gamma_correct: 1    

display:
  - platform: mipi_spi
    id: my_display
    model: st7796
    spi_id: display_spi
    cs_pin: {pca9554: p_c_a, number: 2}
    dc_pin: 
      number: 3
      ignore_strapping_warning: true # Behebt die Fehlermeldung
    reset_pin: {pca9554: p_c_a, number: 1}
    rotation: 90
    update_interval: 0.5s
    invert_colors: true 
    lambda: |-
      it.fill(Color(0,0,0));
      int x_center = it.get_width() / 2;
      int screen_width = it.get_width();
      
      // --- HEADER (45px hoch) ---
      it.filled_rectangle(0, 0, screen_width, 45, Color(40, 40, 40)); 
      it.print(10, 8, id(arial_font_18), Color(255, 255, 255), TextAlign::TOP_LEFT, "BARCODE SCANNER");

      // --- BATTERIE & PROZENT ---
      if (id(batterie_ladestand).has_state()) {
        float level = id(batterie_ladestand).state;
        float threshold = id(akku_warnschwelle).has_state() ? id(akku_warnschwelle).state : 15.0; 
        Color batt_color = Color(0, 255, 0);
        
        if (level < threshold) batt_color = Color(255, 0, 0);
        else if (level < 50.0) batt_color = Color(255, 165, 0);

        bool blink_off = (level < threshold) && !id(batterie_laden).state && ((millis() / 500) % 2 == 0);

        if (!blink_off) {
          int perc_x = screen_width - 5; 
          // batt_x von -100 auf -110 (weiter nach links)
          int batt_x = screen_width - 105; 
          // y_pos von 17 auf 19 (etwas nach unten)
          int y_pos = 19; 

          // 1. Prozentzahl
          it.printf(perc_x, 10, id(arial_font), batt_color, TextAlign::TOP_RIGHT, "%.0f%%", level);

          // 2. Akku Symbol (leicht verkleinert für bessere Optik)
          int b_width = 28;
          int b_height = 14;
          it.rectangle(batt_x, y_pos, b_width, b_height, batt_color);
          it.filled_rectangle(batt_x + b_width, y_pos + 4, 2, 6, batt_color);
          
          int fill_w = (int)((level / 100.0) * (b_width - 4));
          if (fill_w > 0) {
            it.filled_rectangle(batt_x + 2, y_pos + 2, fill_w, b_height - 4, batt_color);
          }
          
          // Lade-Plus über dem Akku
          if (id(batterie_laden).state) {
            it.print(batt_x + (b_width/2), y_pos - 6, id(arial_font), Color(255,255,255), TextAlign::CENTER, "+");
          }
        }
      }

      it.line(0, 45, screen_width, 45, Color(255, 255, 255));
      
      // --- HAUPTBEREICH (SCANNER BEREIT LOGIK) ---
      if (!id(api_ready)) {
        it.print(x_center, 150, id(arial_font_18), Color(255,255,0), TextAlign::CENTER, "System startet...");
      } else {
        std::string ean_status = id(last_ean).state;
        
        if (ean_status == "Bereit zum Scannen" || ean_status.empty() || ean_status == "unknown") {
          it.print(x_center, 160, id(arial_font_18), Color(0,255,0), TextAlign::CENTER, "SCANNER BEREIT");
          it.print(x_center, 200, id(arial_font), Color(100,100,100), TextAlign::CENTER, "Warte auf Barcode...");
        } else {
          // Scan Modus
          it.printf(x_center, 70, id(arial_font_18), Color(150,150,150), TextAlign::TOP_CENTER, "EAN: %s", ean_status.c_str());
          
          if (!id(last_brand).state.empty()) {
            it.print(x_center, 130, id(arial_font_18), Color(255,255,0), TextAlign::CENTER, id(last_brand).state.c_str());
          }
          
          if (!id(last_product).state.empty()) {
            it.print(x_center, 190, id(arial_font), Color(255,255,255), TextAlign::CENTER, id(last_product).state.c_str());
          }
          
          if (!id(last_kcal).state.empty() && id(last_kcal).state != "unknown") {
            std::string s = id(last_kcal).state;
            size_t dot = s.find(".0");
            if (dot != std::string::npos) { s.erase(dot, 2); } 
            it.print(x_center, 260, id(arial_font), Color(0,255,255), TextAlign::CENTER, s.c_str());
          }
        }
      }
      
touchscreen:
  platform: ft63x6
  transform:
    swap_xy: true
    mirror_x: false
    mirror_y: true
  on_touch:
    - lambda: |-
        // Korrigierte Abfrage für den Licht-Status in C++
        if (id(display_backlight).remote_values.is_on()) {
          // Display ist schon an -> Timer verlängern und Log schreiben
          id(display_timer).execute();
          ESP_LOGI("cal", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
              touch.x,
              touch.y,
              touch.x_raw,
              touch.y_raw
          );
        } else {
          // Display ist aus -> Nur aufwecken (Klick wird verschluckt)
          id(display_timer).execute();
          ESP_LOGI("touch", "Display aufgeweckt");
        }
  

  
axp2101:
  id: axp_chip
  update_interval: 30s
      
script:
  - id: display_timer
    mode: restart
    then:
      - light.turn_on: display_backlight
      - delay: 60s
      - light.turn_off: display_backlight 
      
# 1. I2S Hardware-Definition (Keine externen Libs nötig!)
i2s_audio:
  - id: i2s_bus
    i2s_mclk_pin: GPIO12
    i2s_bclk_pin: GPIO13
    i2s_lrclk_pin: GPIO15

# 2. Der Media Player für Home Assistant
media_player:
  - platform: i2s_audio
    name: "Scanner Lautsprecher"
    id: scanner_speaker
    dac_type: external
    i2s_dout_pin: GPIO14
    mode: mono
